<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sungabha Chat — Mesh Group Calls</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    /* Core styling (keeps your color palette and many original design elements) */
    :root{
      --deep-crimson:#8B0000;
      --golden-yellow:#FFD700;
      --royal-blue:#4169E1;
      --off-white:#F5F5F5;
      --cream:#FFFDD0;
      --almost-black:#1C2526;
      --medium-gray:#808080;
      --cool-gray:#B0C4DE;
    }
    body{font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue";margin:0;background:var(--almost-black);color:var(--off-white);-webkit-font-smoothing:antialiased}
    .glass{backdrop-filter:blur(12px);background:rgba(245,245,245,0.06);border:1px solid rgba(245,245,245,0.06)}
    .container{max-width:1100px;margin:18px auto;padding:12px}
    .hidden{display:none}
    /* Chat layout */
    .layout{display:grid;grid-template-columns:320px 1fr;gap:12px;min-height:76vh}
    @media (max-width:900px){.layout{grid-template-columns:1fr}}
    .panel{background:var(--off-white);color:var(--almost-black);padding:12px;border-radius:12px}
    .header{display:flex;align-items:center;justify-content:space-between;padding:8px;background:var(--off-white);border-radius:10px;color:var(--almost-black);margin-bottom:8px}
    .msg-list{height:52vh;overflow:auto;padding:12px;background:linear-gradient(180deg,var(--cream),#fff);border-radius:10px}
    .msg{max-width:70%;padding:10px;border-radius:18px;margin-bottom:8px;box-shadow:0 6px 18px rgba(0,0,0,0.12)}
    .msg.me{margin-left:auto;background:var(--deep-crimson);color:var(--cream)}
    .msg.other{background:var(--off-white);color:var(--almost-black)}
    .input-row{display:flex;gap:8px;margin-top:8px}
    .input-row input[type="text"]{flex:1;padding:10px;border-radius:12px;border:1px solid var(--medium-gray)}
    .btn{padding:8px 12px;border-radius:10px;border:none;cursor:pointer}
    .btn-primary{background:var(--deep-crimson);color:var(--cream)}
    .btn-muted{background:var(--medium-gray);color:#fff}
    /* Video area */
    .video-area{background:transparent;padding:8px;border-radius:12px;display:flex;flex-direction:column;gap:8px}
    .videos{display:flex;gap:8px;flex-wrap:wrap}
    .videos video{background:#000;border-radius:8px;width:100%;max-width:360px;height:210px;object-fit:cover}
    @media(min-width:900px){.videos video{width:48%;height:260px}}
    /* Incoming call modal */
    .call-modal{position:fixed;inset:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:60}
    .call-card{background:var(--off-white);color:var(--almost-black);padding:18px;border-radius:12px;min-width:260px;text-align:center}
    .small{font-size:0.85rem}
  </style>
</head>
<body>
  <div class="container">
    <!-- Top header -->
    <div class="header glass p-4 mb-4">
      <div class="flex items-center gap-3">
        <img src="logo.png" alt="logo" style="width:44px;height:44px;border-radius:8px;object-fit:cover">
        <div>
          <div style="font-weight:700">Sungabha Chat</div>
          <div class="small">Community chat with group video (mesh)</div>
        </div>
      </div>
      <div>
        <span id="userDisplay" class="mr-4 small"></span>
        <button id="signOutBtn" class="btn btn-muted hidden"><i class="fas fa-sign-out-alt"></i> Sign out</button>
      </div>
    </div>

    <!-- Main layout -->
    <div class="layout">
      <!-- Left panel: auth / rooms / users -->
      <div class="panel glass">
        <div id="homePanel">
          <h3 class="small" style="margin-bottom:8px">Sign in / Sign up</h3>
          <input id="nameInput" type="text" placeholder="Display name (for sign-up)" class="w-full p-2 rounded mb-2" />
          <input id="emailInput" type="email" placeholder="Email" class="w-full p-2 rounded mb-2" />
          <input id="passwordInput" type="password" placeholder="Password (≥6)" class="w-full p-2 rounded mb-2" />
          <div class="flex gap-2">
            <button id="signUpBtn" class="btn btn-primary">Create account</button>
            <button id="signInBtn" class="btn btn-muted">Sign in</button>
          </div>
          <hr class="my-3" />
          <div>
            <label class="small">Join or create a room (group call)</label>
            <input id="roomIdInput" type="text" placeholder="room-abc (leave empty to auto-gen)" class="w-full p-2 rounded mt-2" />
            <div class="flex gap-2 mt-2">
              <button id="joinRoomBtn" class="btn btn-primary">Join Room</button>
              <button id="leaveRoomBtn" class="btn btn-muted hidden">Leave</button>
            </div>
            <div id="currentRoom" class="small mt-2 text-gray-600"></div>
          </div>
          <hr class="my-3" />
          <div>
            <label class="small">Active users</label>
            <div id="activeUsers" class="mt-2 small"></div>
          </div>
        </div>
        <div id="infoPanel" class="hidden">
          <p class="small">When in a room, other members will appear and a video element will be created for each.</p>
        </div>
      </div>

      <!-- Right panel: chat + video -->
      <div class="panel glass">
        <div class="video-area">
          <div class="flex items-center justify-between">
            <div style="font-weight:700">Group Video</div>
            <div>
              <button id="muteBtn" class="btn btn-muted small hidden"><i class="fas fa-microphone-slash"></i> Mute</button>
              <button id="camBtn" class="btn btn-muted small hidden"><i class="fas fa-video"></i> Camera</button>
            </div>
          </div>

          <div id="videoPlace" class="videos">
            <!-- videos added dynamically: local + remote -->
            <video id="localVideo" autoplay playsinline muted style="max-width:360px"></video>
          </div>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="startCamBtn" class="btn btn-primary">Start Camera</button>
            <button id="stopCamBtn" class="btn btn-muted hidden">Stop Camera</button>
            <button id="toggleAudioBtn" class="btn btn-muted hidden">Mute/Unmute</button>
          </div>
        </div>

        <hr class="my-4" />

        <div>
          <div class="msg-list" id="chatMessages"></div>
          <div class="input-row mt-2">
            <input id="messageInput" type="text" placeholder="Type message..." />
            <input id="fileInput" type="file" accept="image/*" class="hidden"/>
            <button id="attachBtn" class="btn btn-muted"><i class="fas fa-paperclip"></i></button>
            <button id="sendMsgBtn" class="btn btn-primary"><i class="fas fa-paper-plane"></i></button>
            <button id="startCallBtn" class="btn btn-primary small hidden"><i class="fas fa-phone"></i> Start Call</button>
            <button id="hangupBtn" class="btn btn-muted small hidden"><i class="fas fa-phone-slash"></i> Hang Up</button>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Incoming call modal (optional UX) -->
  <div id="incomingCallModal" class="call-modal hidden">
    <div class="call-card">
      <div id="incomingText" style="font-weight:700">Incoming call</div>
      <div style="margin-top:10px">
        <button id="acceptCallBtn" class="btn btn-primary">Accept</button>
        <button id="rejectCallBtn" class="btn btn-muted">Reject</button>
      </div>
    </div>
  </div>

  <!-- Firebase + App Script -->
  <script type="module">
    /* ===========================
       Firebase & Config
       =========================== */
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js";
    import {
      getDatabase, ref, set, push, onValue, onDisconnect, serverTimestamp,
      get, update, remove
    } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";
    import {
      getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword,
      signOut, onAuthStateChanged, updateProfile, sendEmailVerification, GoogleAuthProvider, signInWithPopup
    } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";

    // Use your firebaseConfig (kept same as in your project)
    const firebaseConfig = {
      apiKey: "AIzaSyCoKAoarWlu8B6cnIw549hfg_UPe8YRSko",
      authDomain: "nepchat-aac9d.firebaseapp.com",
      databaseURL: "https://nepchat-aac9d-default-rtdb.firebaseio.com",
      projectId: "nepchat-aac9d",
      storageBucket: "nepchat-aac9d.firebasestorage.app",
      messagingSenderId: "179485804786",
      appId: "1:179485804786:web:3ec8a2fc563b08c682286b"
    };
    const IMGBB_API_KEY = 'fdeb5290f70387fcaabd7fb9fbe6d6ca'; // your key

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const auth = getAuth(app);

    /* ===========================
       DOM references
       =========================== */
    const nameInput = document.getElementById('nameInput');
    const emailInput = document.getElementById('emailInput');
    const passwordInput = document.getElementById('passwordInput');
    const signUpBtn = document.getElementById('signUpBtn');
    const signInBtn = document.getElementById('signInBtn');
    const signOutBtn = document.getElementById('signOutBtn');
    const userDisplay = document.getElementById('userDisplay');

    const roomIdInput = document.getElementById('roomIdInput');
    const joinRoomBtn = document.getElementById('joinRoomBtn');
    const leaveRoomBtn = document.getElementById('leaveRoomBtn');
    const currentRoomDiv = document.getElementById('currentRoom');
    const activeUsersDiv = document.getElementById('activeUsers');

    const localVideo = document.getElementById('localVideo');
    const videoPlace = document.getElementById('videoPlace');
    const startCamBtn = document.getElementById('startCamBtn');
    const stopCamBtn = document.getElementById('stopCamBtn');
    const toggleAudioBtn = document.getElementById('toggleAudioBtn');

    const chatMessages = document.getElementById('chatMessages');
    const messageInput = document.getElementById('messageInput');
    const sendMsgBtn = document.getElementById('sendMsgBtn');
    const attachBtn = document.getElementById('attachBtn');
    const fileInput = document.getElementById('fileInput');

    const startCallBtn = document.getElementById('startCallBtn');
    const hangupBtn = document.getElementById('hangupBtn');

    const incomingCallModal = document.getElementById('incomingCallModal');
    const incomingText = document.getElementById('incomingText');
    const acceptCallBtn = document.getElementById('acceptCallBtn');
    const rejectCallBtn = document.getElementById('rejectCallBtn');

    /* ===========================
       App State
       =========================== */
    let currentUser = null;
    let currentDisplayName = null;
    let currentUsername = null;
    let currentRoomId = null;
    let localStream = null;

    // connections[peerId] = { pc: RTCPeerConnection, remoteEl: videoElement }
    const connections = {};

    // STUN servers (free)
    const STUN_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    /* ===========================
       Auth handlers
       =========================== */
    signUpBtn.addEventListener('click', async () => {
      const name = nameInput.value.trim();
      const email = emailInput.value.trim();
      const pw = passwordInput.value;
      if (!name || !email || !pw || pw.length < 6) return alert('Provide name, valid email and password (>=6).');
      try {
        const cred = await createUserWithEmailAndPassword(auth, email, pw);
        await updateProfile(cred.user, { displayName: name });
        await sendEmailVerification(cred.user);
        alert('Account created. Check email for verification.');
      } catch (e) { console.error(e); alert(e.message || e); }
    });

    signInBtn.addEventListener('click', async () => {
      const email = emailInput.value.trim();
      const pw = passwordInput.value;
      if (!email || !pw) return alert('Enter email and password');
      try {
        await signInWithEmailAndPassword(auth, email, pw);
      } catch (e) { console.error(e); alert(e.message || e); }
    });

    signOutBtn.addEventListener('click', async () => {
      try {
        await signOut(auth);
      } catch (e) { console.error(e); }
    });

    onAuthStateChanged(auth, (user) => {
      if (user) {
        if (!user.emailVerified) {
          alert('Please verify your email before using the chat.');
          // Optionally sign the user out or show verification UI
        }
        currentUser = user;
        currentDisplayName = user.displayName || user.email.split('@')[0];
        currentUsername = sanitizeUsername(user.email.split('@')[0]);
        userDisplay.textContent = currentDisplayName;
        signOutBtn.classList.remove('hidden');
        document.getElementById('homePanel').classList.add('hidden');
        document.getElementById('infoPanel').classList.remove('hidden');
        listenForMessages();
        setupPresence();
      } else {
        // signed out
        currentUser = null;
        currentDisplayName = null;
        currentUsername = null;
        userDisplay.textContent = '';
        signOutBtn.classList.add('hidden');
        document.getElementById('homePanel').classList.remove('hidden');
        document.getElementById('infoPanel').classList.add('hidden');
        leaveRoom(); // cleanup
        clearChatUI();
      }
    });

    function sanitizeUsername(s) {
      return s.replace(/[.#$[\]]/g, '_');
    }

    /* ===========================
       Presence & active users
       =========================== */
    function setupPresence() {
      if (!currentUser) return;
      const userRef = ref(db, `activeUsers/${currentUser.uid}`);
      const userStatus = { name: currentDisplayName, username: currentUsername, status: 'online', lastSeen: serverTimestamp() };
      set(userRef, userStatus);
      onDisconnect(userRef).remove();
      // update active users list in UI
      onValue(ref(db, 'activeUsers'), snap => {
        const val = snap.val() || {};
        activeUsersDiv.innerHTML = Object.values(val).map(u => `<div>${escapeHtml(u.name)} <span class="small text-gray-600">@${escapeHtml(u.username)}</span></div>`).join('') || '<div class="small text-gray-600">No active users</div>';
      });
    }

    /* ===========================
       Chat: send/receive messages (simple)
       =========================== */
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {/* handled during send */});

    sendMsgBtn.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendMessage(); });

    async function sendMessage() {
      if (!currentUser) return alert('Sign in first');
      const text = messageInput.value.trim();
      let fileUrl = null;
      let fileName = null;
      if (fileInput.files.length) {
        const f = fileInput.files[0];
        if (f.size > 32 * 1024 * 1024) return alert('File too large (32MB limit)');
        try {
          const base64 = await readFileAsBase64(f);
          const fd = new FormData();
          fd.append('key', IMGBB_API_KEY);
          fd.append('image', base64.split(',')[1]);
          fd.append('name', f.name);
          const res = await fetch('https://api.imgbb.com/1/upload', { method: 'POST', body: fd });
          const j = await res.json();
          if (j.success) { fileUrl = j.data.url; fileName = f.name; }
        } catch (e) { console.error(e); alert('Upload failed'); }
      }
      if (!text && !fileUrl) return;
      const data = { user: currentDisplayName, username: currentUsername, text: text || (fileName || ''), timestamp: Date.now(), type: fileUrl ? 'file' : 'text', fileUrl, fileName };
      try {
        await push(ref(db, 'messages'), data);
        messageInput.value = ''; fileInput.value = '';
      } catch (e) { console.error(e); alert('Send failed'); }
    }

    function listenForMessages() {
      onValue(ref(db, 'messages'), snap => {
        const msgs = snap.val() || {};
        chatMessages.innerHTML = '';
        Object.entries(msgs).sort((a,b)=> (a[1].timestamp||0)-(b[1].timestamp||0)).forEach(([id, msg]) => {
          const div = document.createElement('div');
          div.className = 'msg ' + (msg.username === currentUsername ? 'me' : 'other');
          let inner = `<div style="font-size:0.8rem;font-weight:600">${escapeHtml(msg.user)}</div>`;
          if (msg.type === 'file' && msg.fileUrl) inner += `<div style="margin-top:6px"><a href="${escapeHtml(msg.fileUrl)}" target="_blank"><img src="${escapeHtml(msg.fileUrl)}" style="max-width:150px;border-radius:8px"></a></div>`;
          if (msg.text) inner += `<div style="margin-top:6px">${escapeHtml(msg.text)}</div>`;
          inner += `<div class="small" style="margin-top:6px;color:${msg.username===currentUsername?'#FFFDD0':'#808080'}">${new Date(msg.timestamp).toLocaleTimeString()}</div>`;
          div.innerHTML = inner;
          chatMessages.appendChild(div);
        });
        chatMessages.scrollTop = chatMessages.scrollHeight;
      });
    }

    function clearChatUI() { chatMessages.innerHTML = ''; }

    function readFileAsBase64(file){ return new Promise((res, rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }) }
    function escapeHtml(str){ if(!str) return ''; return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }

    /* ===========================
       Mesh Group Call Implementation
       ===========================
       Structure in RTDB:
       rooms/{roomId}/peers/{uid}/offers/{targetUid}   -> caller stores offer for target
       rooms/{roomId}/peers/{uid}/answers/{fromUid}   -> callee writes answer for offer author
       rooms/{roomId}/peers/{uid}/ice/{otherUid}      -> ICE candidates exchanged
       NOTE: This implementation uses a "symmetric" offers/answers approach:
         - When a new peer A sees peer B and needs to connect, A will create an offer addressed to B:
            set rooms/roomId/peers/A/offers/B = offer
         - B listens for offers targeted to B and responds by writing answers under:
            set rooms/roomId/peers/B/answers/A = answer
         - ICE candidates are pushed to rooms/roomId/peers/{owner}/ice/{target}/randomKey
       This pattern simplifies mapping pairs and scaling generalization.
    =========================== */

    joinRoomBtn.addEventListener('click', async () => {
      if (!currentUser) return alert('Sign in first');
      let roomId = roomIdInput.value.trim();
      if (!roomId) {
        roomId = 'room-' + Math.random().toString(36).slice(2,9);
        roomIdInput.value = roomId;
      }
      await joinRoom(roomId);
    });

    leaveRoomBtn.addEventListener('click', () => { leaveRoom(); });

    async function joinRoom(roomId) {
      if (!currentUser) return;
      if (currentRoomId === roomId) return;
      // leave previous
      await leaveRoom();
      currentRoomId = roomId;
      currentRoomDiv.textContent = `Room: ${roomId}`;
      joinRoomBtn.classList.add('hidden');
      leaveRoomBtn.classList.remove('hidden');

      // add self to room peers
      await set(ref(db, `rooms/${roomId}/peers/${currentUser.uid}/meta`), { name: currentDisplayName, joinedAt: serverTimestamp() });
      // ensure cleanup on disconnect:
      onDisconnect(ref(db, `rooms/${roomId}/peers/${currentUser.uid}`)).remove();

      // prepare local media (but do not force camera; we'll create localStream once needed)
      // show local video placeholder (will be set when localStream ready)
      createOrShowLocalVideo();

      // watch peers list to connect to newcomers
      onValue(ref(db, `rooms/${roomId}/peers`), async (snap) => {
        const peers = snap.val() || {};
        // Update small UI
        activeUsersDiv.innerHTML = Object.entries(peers).map(([uid, d]) => `<div>${escapeHtml(d.meta?.name||uid)} <span class="small">@${uid}</span></div>`).join('') || '<div class="small text-gray-600">No peers</div>';

        // For each peer, if it's not me and we don't yet have a connection, initiate connection (offer)
        for (const peerId of Object.keys(peers)) {
          if (peerId === currentUser.uid) continue;
          if (!connections[peerId]) {
            await createOfferToPeer(peerId);
          }
        }
      });

      // Listen for offers targeted to me (someone wrote offers/{targetUid} under their peer node)
      onValue(ref(db, `rooms/${roomId}/peers`), async (snap) => {
        const allPeers = snap.val() || {};
        // walk every peer's offers targeted at me
        for (const otherId in allPeers) {
          if (otherId === currentUser.uid) continue;
          const offersNode = allPeers[otherId]?.offers || {};
          const offerForMe = offersNode[currentUser.uid];
          if (offerForMe && !connections[otherId]) {
            // answer the offer
            await answerOfferFromPeer(otherId, offerForMe);
          }
        }
      });

      // Listen for answers intended for offers we created
      onValue(ref(db, `rooms/${roomId}/peers/${currentUser.uid}/answers`), async (snap) => {
        const answers = snap.val() || {};
        for (const fromId in answers) {
          const answer = answers[fromId];
          const conn = connections[fromId];
          if (conn && conn.pc && conn.pc.signalingState !== 'closed') {
            try {
              await conn.pc.setRemoteDescription(new RTCSessionDescription(answer));
            } catch (e) { console.error('setRemoteDescription (answer) failed', e); }
          }
        }
      });

      // Listen for ICE candidates addressed to me (from others: rooms/roomId/peers/{other}/ice/{myId})
      onValue(ref(db, `rooms/${roomId}/peers`), async (snap) => {
        const all = snap.val() || {};
        for (const otherId in all) {
          if (otherId === currentUser.uid) continue;
          const iceBucket = all[otherId]?.ice || {};
          const myIce = iceBucket[currentUser.uid] || {};
          // myIce is a map of candidateNodes
          for (const key in myIce) {
            const candidate = myIce[key];
            const conn = connections[otherId];
            if (conn && conn.pc) {
              try {
                await conn.pc.addIceCandidate(new RTCIceCandidate(candidate));
              } catch (e) {
                console.error('Error adding ICE candidate (callee side)', e);
              }
            }
          }
        }
      });

      // For cleanup: listen to room removal/hangs
      onValue(ref(db, `rooms/${roomId}`), (snap) => {
        const r = snap.val();
        if (!r) {
          // room removed
          leaveRoom();
        }
      });
    }

    async function leaveRoom() {
      if (!currentRoomId) return;
      // remove self from room peers
      try { await remove(ref(db, `rooms/${currentRoomId}/peers/${currentUser.uid}`)); } catch (e) {}
      // close all peer connections
      for (const peerId in connections) {
        try { connections[peerId].pc.close(); } catch (e) {}
        // remove video element
        if (connections[peerId].remoteEl && connections[peerId].remoteEl.parentNode) connections[peerId].remoteEl.remove();
        delete connections[peerId];
      }
      // stop local media
      if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream = null; localVideo.srcObject = null; }
      currentRoomId = null;
      currentRoomDiv.textContent = '';
      joinRoomBtn.classList.remove('hidden');
      leaveRoomBtn.classList.add('hidden');
    }

    /* ===== Create or show local video element placeholder ===== */
    function createOrShowLocalVideo() {
      // localVideo element already exists in DOM; ensure visible
      if (!localVideo.srcObject && !localStream) {
        // keep muted local placeholder until camera started
      }
      if (!videoPlace.contains(localVideo)) videoPlace.prepend(localVideo);
    }

    /* ===== Create offer (A -> B) =====
       A: create peer connection to B, add local tracks, create offer,
          set local description, then write offer at rooms/roomId/peers/A/offers/B
       Then listen for answer under rooms/roomId/peers/A/answers/B
    ===== */
    async function createOfferToPeer(peerId) {
      if (!currentRoomId || !currentUser) return;
      // ensure localStream exists
      if (!localStream) {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
          localVideo.srcObject = localStream;
        } catch (e) {
          console.error('getUserMedia (offer) failed', e);
          return;
        }
      }

      const pc = new RTCPeerConnection(STUN_SERVERS);
      // add tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      // create remote video element
      const remoteEl = document.createElement('video');
      remoteEl.autoplay = true; remoteEl.playsInline = true;
      remoteEl.id = `remote-${peerId}`;
      videoPlace.appendChild(remoteEl);

      // ontrack
      pc.ontrack = (evt) => {
        remoteEl.srcObject = evt.streams[0];
      };

      // ICE: push to rooms/{room}/peers/{myId}/ice/{peerId}/{random}
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          push(ref(db, `rooms/${currentRoomId}/peers/${currentUser.uid}/ice/${peerId}`), event.candidate.toJSON());
        }
      };

      // store connection
      connections[peerId] = { pc, remoteEl };

      // create offer
      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        // write offer targeted to peerId under my peer node
        await set(ref(db, `rooms/${currentRoomId}/peers/${currentUser.uid}/offers/${peerId}`), offer.toJSON());
      } catch (e) {
        console.error('createOffer error', e);
      }
    }

    /* ===== Answer an offer from peer (B receives an offer created by A) =====
       otherId = A (author of the offer)
       offerForMe = offer object
    ===== */
    async function answerOfferFromPeer(otherId, offerForMe) {
      if (!currentRoomId || !currentUser) return;
      // create peer connection
      if (!localStream) {
        try { localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true }); localVideo.srcObject = localStream; } catch (e) { console.error('getUserMedia (answer) failed', e); return; }
      }

      const pc = new RTCPeerConnection(STUN_SERVERS);
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      const remoteEl = document.createElement('video');
      remoteEl.autoplay = true; remoteEl.playsInline = true;
      remoteEl.id = `remote-${otherId}`;
      videoPlace.appendChild(remoteEl);

      pc.ontrack = (evt) => {
        remoteEl.srcObject = evt.streams[0];
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // write ICE candidate for caller to pick up under caller's remoteIce node
          push(ref(db, `rooms/${currentRoomId}/peers/${currentUser.uid}/ice/${otherId}`), event.candidate.toJSON());
        }
      };

      connections[otherId] = { pc, remoteEl };

      try {
        // set remote (the offer)
        await pc.setRemoteDescription(new RTCSessionDescription(offerForMe));
        // create answer
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        // write answer under my answers node referencing the offer author
        await set(ref(db, `rooms/${currentRoomId}/peers/${currentUser.uid}/answers/${otherId}`), answer.toJSON());
      } catch (e) {
        console.error('answerOfferFromPeer failed', e);
      }

      // also listen for ICE candidates that the caller pushed
      onValue(ref(db, `rooms/${currentRoomId}/peers/${otherId}/ice/${currentUser.uid}`), (snap) => {
        const items = snap.val() || {};
        for (const k in items) {
          const candidate = items[k];
          try { pc.addIceCandidate(new RTCIceCandidate(candidate)); } catch (e) { console.error('addIceCandidate (answer) error', e); }
        }
      });
    }

    /* ===========================
       Local camera controls
       =========================== */
    startCamBtn.addEventListener('click', async () => {
      try {
        if (!localStream) {
          localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
          localVideo.srcObject = localStream;
        }
        startCamBtn.classList.add('hidden'); stopCamBtn.classList.remove('hidden'); toggleAudioBtn.classList.remove('hidden');
      } catch (e) { console.error('Camera error', e); alert('Cannot access camera/mic'); }
    });
    stopCamBtn.addEventListener('click', () => {
      if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream = null; localVideo.srcObject = null; }
      startCamBtn.classList.remove('hidden'); stopCamBtn.classList.add('hidden'); toggleAudioBtn.classList.add('hidden');
    });

    toggleAudioBtn.addEventListener('click', () => {
      if (!localStream) return;
      const audioTrack = localStream.getAudioTracks()[0];
      if (!audioTrack) return;
      audioTrack.enabled = !audioTrack.enabled;
      toggleAudioBtn.textContent = audioTrack.enabled ? 'Mute' : 'Unmute';
    });

    /* ===========================
       Utility: Cleanup on page unload
       =========================== */
    window.addEventListener('beforeunload', async () => {
      if (currentRoomId && currentUser) {
        try { await remove(ref(db, `rooms/${currentRoomId}/peers/${currentUser.uid}`)); } catch(e) {}
      }
      // close pcs
      for (const k in connections) try{ connections[k].pc.close(); }catch(e){}
      if (localStream) localStream.getTracks().forEach(t=>t.stop());
    });

    /* ===========================
       Optional: start a direct call button (create offers to everyone)
       =========================== */
    startCallBtn.addEventListener('click', async () => {
      // create offers to all existing peers
      if (!currentRoomId) return alert('Join a room first');
      const snapshot = await get(ref(db, `rooms/${currentRoomId}/peers`));
      const peers = snapshot.val() || {};
      for (const peerId in peers) {
        if (peerId === currentUser.uid) continue;
        if (!connections[peerId]) await createOfferToPeer(peerId);
      }
      startCallBtn.classList.add('hidden'); hangupBtn.classList.remove('hidden');
    });

    hangupBtn.addEventListener('click', async () => {
      // gracefully leave room and close connections
      await leaveRoom();
      startCallBtn.classList.remove('hidden'); hangupBtn.classList.add('hidden');
    });

    /* ===========================
       Ready
       =========================== */
    // Small helper to show a message on load/when needed
    console.log('App loaded — ready for sign-in and room join (mesh group calls).');
  </script>
</body>
</html>